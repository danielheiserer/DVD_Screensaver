<!DOCTYPE html>
<html>
<head>
	<style>
		body {
			margin:0;
		}

		.wrap{
			overflow: hidden;
		}

		.bounce_container {
			transform: rotate3d(1, 0, 0, 0deg);
			transform-style: preserve-3d;
			height: 100vh;
			width: 100vw;
			transition: 2s all ease-in-out;
		}

		.bounce_field {
			overflow: hidden;
			height: 100%;
			width: 100%;
			position: relative;
			background: powderblue;
			transform: translate3d(0px, 0px, 50vh);
		}

		.bottom_face {
			background: beige;
			transform: translate(0px, -50vh) rotate3d(1,0,0,90deg);
			height: 100%;
			width: 100%;
		}

		.block {
			height: 50px;
			width: 50px;
			position: absolute;
			top: calc(50% - 25px);
			left: calc(50% - 25px);
			z-index: 1;
			box-sizing: border-box;
			border-radius: 50%;
			will-change: left, top;
			background: radial-gradient(90deg, rgba(0,0,0,1) 25%, rgba(255,0,0,1) 50%, rgba(255,252,0,1) 75%);
			animation: spin 1s infinite linear;
			pointer-events: none;
		}

		.block.debug {
			background: yellowgreen;
			border: solid green 20px;
			opacity: .7;
		}

		.angle,
		.angle_shadow {
			background: black;
			height: 2000px;
			width: 2px;
			position: absolute;
			left: calc(50% - 1px);
			bottom: calc(50% - 2000px);
			transform: rotate(360deg);
			border-bottom: white solid 2000px;
		}

		.angle_shadow {
			background: #dedede;
			z-index: -1;
			border-left: 24px solid aliceblue;
			border-right: 24px solid aliceblue;
			left: calc(50% - 25px);
		}

		.display {
			position: absolute;
			bottom: 60px;
			left: 25px;
			height: 20px;
			width: 50px;
			background: powderblue;
			opacity: .8;
			padding: 10px;
		}

		.origin_control {
			background: lightcyan;
			height: 10px;
			width: 10px;
			position: absolute;
			left: calc(50% - 15px);
			bottom: calc(50% - 15px);
			border-radius: 50%;
			opacity: .7;
			border: indianred 10px solid;
			cursor: grab;
		}

		.origin_control.grabbing {
			cursor: grabbing;
		}

		.display input{
			max-width: 90%;
		}

		.reset_button {
			position: absolute;
			bottom: 15px;
			left: 25px;
			height: 20px;
			width: 50px;
			background: powderblue;
			opacity: .8;
			padding: 10px;
			cursor: pointer;
		}

		.debug_ankathete_element {
			background: aqua;
			height: 2000px;
			width: 2px;
			position: absolute;
			left: calc(50% + 1px);
			bottom: calc(50% - 2000px);
			border-bottom: white solid 2000px;
		}

		.debug_gegenkathete_element {
			background: green;
			height: 2000px;
			width: 2px;
			position: absolute;
			left: calc(50% + 1px);
			bottom: calc(50% - 2000px);
			border-bottom: white solid 2000px;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/******************************************
		** Cube CSS
		******************************************/

		.cube {
				height: 52px;
				width: 52px;
	    		position: absolute;
	    		top: calc(50% - 26px);
				left: calc(50% - 26px);
	    		/*border:red 1px solid;*/
	    		transform: rotate3d(1, 1, 0, 77deg);
	    		transform-style: preserve-3d;
	    		animation: cube_spin linear 5s infinite;
	    		z-index: 1;
				pointer-events: none;
			}

			@keyframes cube_spin {
				0% { transform: rotate3d(1, 1, 0, 0deg); }
				100% { transform: rotate3d(1, 1, 0, 360deg); }
			}

			.cube .side {
				height: 52px;
				width: 52px;
				position: absolute;
				background: #F0F0F0;
	    		border: 1px solid #dedede;
	    		box-sizing:border-box;

			}

			.face-one {
				transform: translate3d(0px, 0px, 25px);
			}

			.face-one .dot:first-child{
				top: calc(50% - 6px);
				left: calc(50% - 6px);
			}

			.face-two {
				transform:translate(25px, 0px) rotate3d(0, 1, 0, 90deg);
			}

			.face-two .dot:nth-child(1){
				bottom: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-two .dot:nth-child(2){
				top: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-three {
				transform:translate(0px, 25px) rotate3d(1, 0, 0, 90deg);
			}

			.face-three .dot:nth-child(1){
				bottom: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-three .dot:nth-child(2){
				top: calc(50% - 6px);
				left: calc(50% - 6px);
			}

			.face-three .dot:nth-child(3){
				top: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-four {
				transform:translate(0px, -25px) rotate3d(1, 0, 0, 90deg);
			}

			.face-four .dot:nth-child(1){
				top: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-four .dot:nth-child(2){
				bottom: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-four .dot:nth-child(3){
				top: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-four .dot:nth-child(4){
				bottom: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-five {
				transform:translate(-25px, 0px) rotate3d(0, 1, 0, 90deg);
			}

			.face-five .dot:nth-child(1){
				top: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-five .dot:nth-child(2){
				bottom: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-five .dot:nth-child(3){
				top: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-five .dot:nth-child(4){
				bottom: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-five .dot:nth-child(5){
				top: calc(50% - 6px);
				left: calc(50% - 6px);
			}

			.face-six {
				transform:translate3d(0px, 0px, -25px);
			}

			.face-six .dot:nth-child(1){
				top: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-six .dot:nth-child(2){
				top: calc(50% - 6px);
				left: calc(11px - 6px);
			}

			.face-six .dot:nth-child(3){
				bottom: calc(11px - 6px);
				left: calc(11px - 6px);
			}

			.face-six .dot:nth-child(4){
				top: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.face-six .dot:nth-child(5){
				top: calc(50% - 6px);
				right: calc(11px - 6px);
			}

			.face-six .dot:nth-child(6){
				bottom: calc(11px - 6px);
				right: calc(11px - 6px);
			}

			.cube .side .dot {
				background: black;
				height: 12px;
				width: 12px;
				border-radius: 50%;
				position: absolute;
			}

		.text {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: 10;
			margin: 0;
			transform: translate(-50%,-50%);
			color: #0a0;
			font-size: 15rem;
			text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
		}

		.bottom_face .text {
			font-size: 10rem;
			transform: rotate3d(1,0,0,180deg) translate(-50%,50%);
		}



			/** class for activating pointer related stuff **/
			.pointer-events-activated {
				pointer-events: all;
			}


	</style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
</head>
<body>
	<div class="wrap">
		<div class="bounce_container">
			<div class="bounce_field"></div>
			<div class="bottom_face"></div>
		</div>
	</div>
</body>
<script>
	// TO-DO
	// Bounce() sollte mehr Funktionen nutzen? (Auslagerung)
	// Div in figure umändern
	// random Color funktion liefert manchmal transparente Farben -> passiert wenn der hexcode 4 oder 8 Stellen hat
	//https://cssanimation.rocks/spheres/ -> für Spheres

	var debug = false;
	var debug_bounce_counter = 0;
	var debug_bounce_limit = 10;
	var start_time = '';
	var end_time = '';
	$(document).ready(function () {

		var block_speed = false; //in px per second

		if (debug) {
			let angle = document.createElement('DIV');
			$(angle).addClass('angle');
			$('.bounce_field').append(angle);

			let display = document.createElement('DIV');
			$(display).addClass('display');
			let displayinput = document.createElement('INPUT');
			$(displayinput).attr('type', 'number');
			$(displayinput).val(302);
			$(display).append(displayinput);
			$('.bounce_field').append(display);

			let angle_shadow = document.createElement('DIV');
			$(angle_shadow).addClass('angle_shadow');
			$('.bounce_field').append(angle_shadow);
			let val = $('.display input').first().val();
			$(angle_shadow).css('transform', 'rotate(' + val + 'deg');

			let drag = false;
			let origin_control = document.createElement('DIV');
			$(origin_control).addClass('origin_control');
			$(origin_control).mousedown(function(){
				$(origin_control).css('cursor', 'grabbing');
				drag = true;
			});
			$('.bounce_field').mousemove(function(){
				if(drag){
					$(origin_control).css({
						top: 'calc(' + event.pageY + 'px - 15px)',
						left: 'calc(' + event.pageX + 'px - 15px)'
					});
					$(angle_shadow).css({
						top: 'calc(' + event.pageY + 'px - 2000px)',
						left: 'calc(' + event.pageX + 'px - 25px)'
					});
				}
			});
			$(origin_control).mouseup(function(){
				$(origin_control).css('cursor', 'grab');
				drag = false;
			});
			$('.bounce_field').append(origin_control);

			let reset_button = document.createElement('DIV');
			$(reset_button).addClass('reset_button');
			$(reset_button).html('Reset');
			$('.bounce_field').append(reset_button);
			$('.reset_button').bind('click', reset);

			$('.display input').change(function() {
				let val = $('.display input').first().val();
				val = Math.abs(val % 360);
				$('.display input').first().val(val);
				$('.angle_shadow').css('transform', 'rotate(' + val + 'deg');
			});

		}
		// init..
		if (!debug){
					let delay = 200;
					let anz_elements = 25;
					for (let i = 0; i < anz_elements; i++) {
						setTimeout(function () {
							bounce(get_random_degree());
						}, i * delay);
					}

					setTimeout(function () {
						let ready = $("<p class='text'></p>").text("Ready?");
						$(".bounce_field").append(ready);
						setTimeout(function () {$('.text').fadeOut();},500);
					}, delay * anz_elements);

					setTimeout(function () {
						let go = $("<p class='text'></p>").text("GO!");
						$(".bounce_field").append(go);
						start_time = new Date();
						setTimeout(function () {$('.text').fadeOut();},500);
						$('.bounce_field .cube, .bounce_field .block').addClass('pointer-events-activated');
					}, delay * anz_elements + 1500);

			}

		function get_random_degree() {
			return parseInt(Math.random() * 100000 % 360);
		}

		function reset() {
			$('.block').remove();
			$('.debug_ankathete_element').remove();
			$('.debug_gegenkathete_element').remove();
			let block = document.createElement('DIV');
			$(block).addClass('block debug');
			let posx = parseInt($('.origin_control').css('left')) + 15;
			let posy = parseInt($('.origin_control').css('top')) + 15;
			console.log('Posx = ' + posx + '   Posy= ' + posy);
			$('.bounce_field').append(block);
			$(block).css({
				top: 'calc(' + posy + 'px - 25px)',
				left: 'calc(' + posx + 'px - 25px)'
			});

			debug_bounce_counter = 0;

			let	degree = $('.display input')[0].value;

			bounce(degree, block);
		}

	});

	function getRandomColor(){
		let hex = Math.floor(Math.random()*16777215).toString(16);
		if (hex.length == 5){
			hex = 0 + hex;
		}
		return '#' + hex;
	}

	function getRandomNumber(lower_limit, upper_limit) {
		return (parseInt((Math.random() * 10000000000000000)) % (upper_limit + 1 - lower_limit)) + lower_limit;
	}

	function bounce(einfallswinkel, block = null, seite = 'init', block_type = false) {
		let background = false;
		if (block_type == false){
			let which_block_type = getRandomNumber(1,10);
			if(which_block_type > 7){
				block_type = "cube";
			}else {
				block_type = "circle";
			}
		}
		if(block == null) {
			if(block_type == "cube"){
				block = document.createElement('DIV');
				$(block).addClass('cube');

				let face_one = document.createElement('DIV');
				$(face_one).addClass('face-one side');
				for(let i = 0; i < 1; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_one).append(dot);
				}
				

				let face_two = document.createElement('DIV');
				$(face_two).addClass('face-two side');
				for(let i = 0; i < 2; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_two).append(dot);
				}

				let face_three = document.createElement('DIV');
				$(face_three).addClass('face-three side');
				for(let i = 0; i < 3; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_three).append(dot);
				}

				let face_four = document.createElement('DIV');
				$(face_four).addClass('face-four side');
				for(let i = 0; i < 4; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_four).append(dot);
				}

				let face_five = document.createElement('DIV');
				$(face_five).addClass('face-five side');
				for(let i = 0; i < 5; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_five).append(dot);
				}

				let face_six = document.createElement('DIV');
				$(face_six).addClass('face-six side');
				for(let i = 0; i < 6; i++){
					let dot = document.createElement('DIV');
					$(dot).addClass('dot');
					$(face_six).append(dot);
				}

			
				block = document.createElement('DIV');
				$(block).addClass('cube');
				$(block).append(face_one);
				$(block).append(face_two);
				$(block).append(face_three);
				$(block).append(face_four);
				$(block).append(face_five);
				$(block).append(face_six);

			}else {
				block = document.createElement('DIV');
				$(block).addClass('block');
				let randomColor1 = getRandomColor();
				let randomColor2 = getRandomColor();
				let randomRadius = getRandomNumber(100, 200);

				let gradient_circle = randomRadius * 0.25;

				background = 'radial-gradient(circle at ' + gradient_circle + 'px ' + gradient_circle + 'px, '+  randomColor1 + ', ' + randomColor2 + ')';
				$(block).css({
					'background': background,
					height : randomRadius + 'px',
					width : randomRadius + 'px',
				});
			}

			$('.bounce_field').append(block);

			$(block).bind("mouseover",function(){
				$(this).css('border', 'solid 5px red');
				$(this).addClass('tagged');
				let anz_bounce_items = $('.block, .cube').length

				if ($('.bounce_field .tagged').length == anz_bounce_items){
					$('.bounce_field .cube, .bounce_field .block').removeClass('pointer-events-activated');
					end_time = new Date();
					let dif = (end_time.getTime() - start_time.getTime()) / 1000;
					let go = $("<p class='text'></p>").text("Zeit: " + dif + 's');
					$(".bottom_face").append(go);
					$('.bounce_container').css('transform', 'rotate3d(1, 0, 0, 90deg)');
				}
			});
		}

		let ausfallswinkel = false;
		//einfallswinkel = ausfallswinkel
		if(seite == 'oben' || seite == 'unten') {
			ausfallswinkel = 180 - einfallswinkel;
			if (ausfallswinkel < 0) {
				ausfallswinkel = 360 + ausfallswinkel;
			}
		} else if(seite == 'init'){
			ausfallswinkel = einfallswinkel;

		}else {
			ausfallswinkel = Math.abs(360 - einfallswinkel);
		}

		let block_width = parseInt($(block).css('width'));
		let block_height = parseInt($(block).css('height'));

		let block_top = parseInt($(block).css('top'));
		let block_bottom = parseInt($(block).css('top')) + block_height;
		let block_left = parseInt($(block).css('left'));
		let block_right = parseInt($(block).css('left')) + block_width;

		let hypotenuse = false;
		let block_speed = 250; //in px pro Sekunde
		let time_next_bounce = 2;

		let debug_ankathete = false;
		let debug_gegenkathete = false;
		let debug_direction = false;

		let space_top = false;
		let space_bottom = false;
		let space_left = false;
		let space_right = false;

		let ankathete_oben = false;
		let gegenkathete_oben = false;
		let ankathete_unten = false;
		let gegenkathete_unten = false;
		let ankathete_links = false;
		let gegenkathete_links = false;
		let ankathete_rechts = false;
		let gegenkathete_rechts = false;

		let distanz = false;
		let framecollision = false;

		let rotate_value = false;

		let correct = false;
		let correct_top = false;
		let correct_side = false;

		let correct_top_kathete = false;
		let correct_side_kathete = false;

		let hypotenuse_top = false;
		let hypotenuse_side = false;

		let corrected_top = false;
		let corrected_side = false;

		switch (true) {
			case (ausfallswinkel < 90):
				space_top = block_top;
				space_right = Math.abs(block_right - $('.bounce_field').width());

				//check oben
				ankathete_oben = space_top + block_height / 2;
				gegenkathete_oben = parseInt(Math.abs(Math.tan((ausfallswinkel * Math.PI) / 180) * ankathete_oben));

				//checken rechts
				ankathete_rechts = space_right + block_width / 2;
				gegenkathete_rechts = parseInt(Math.abs(Math.tan(((90 - ausfallswinkel) * Math.PI) / 180) * ankathete_rechts));


				//Positionskorrektur
				correct = 0;

				// a^2 + b^2 = c^2 -> im ersten Schritt ist correct_x a oder b und im zweiten c

				correct_top_kathete = parseInt(Math.abs(Math.tan((ausfallswinkel * Math.PI) / 180) * (block_height / 2)));
				correct_top = parseInt(Math.sqrt(Math.pow(correct_top_kathete, 2) + Math.pow(block_height / 2, 2)));

				correct_side_kathete = parseInt(Math.abs(Math.tan(((90 - ausfallswinkel) * Math.PI) / 180) * block_width / 2));
				correct_side = parseInt(Math.sqrt(Math.pow(correct_side_kathete, 2) + Math.pow(block_width / 2, 2)));

				hypotenuse_top = parseInt(Math.sqrt(Math.pow(ankathete_oben, 2) + Math.pow(gegenkathete_oben, 2)));
				hypotenuse_side = parseInt(Math.sqrt(Math.pow(ankathete_rechts, 2) + Math.pow(gegenkathete_rechts, 2)));

				//kürzere Rute

				corrected_top = Math.abs((hypotenuse_top - correct_top));
				corrected_side = Math.abs((hypotenuse_side - correct_side));

				if(corrected_top < corrected_side){
					distanz = gegenkathete_oben;
					framecollision = 'oben';
				}else {
					distanz = gegenkathete_rechts;
					framecollision = 'rechts';
				}

				if (framecollision == 'oben'){
					hypotenuse = hypotenuse_top - correct_top;
					correct = correct_top_kathete;
				}else {
					hypotenuse = hypotenuse_side - correct_side;
					correct = correct_side_kathete;
				}

				debug_direction = framecollision;
				if (debug_direction == 'oben') {
					debug_direction = 'quad_1_oben';
					debug_ankathete = ankathete_oben;
					debug_gegenkathete = gegenkathete_oben;
				}else {
					debug_direction = 'quad_1_rechts';
					debug_ankathete = ankathete_rechts;
					debug_gegenkathete = gegenkathete_rechts;
				}

				//geschw noch ausrechnen time_next_bounce

				time_next_bounce = hypotenuse / block_speed;

				$(block).css({
					transition: "top linear " + time_next_bounce + "s, left linear " + time_next_bounce + "s"
				});

				rotate_value = 'rotate(' + ausfallswinkel + 'deg)';
				$('.angle').css({
					transform: rotate_value
				});

				if (framecollision == 'oben') {
					$(block).css({
						top: "0",
						left: block_left + distanz - correct
					});
				}else{
					$(block).css({
						top: block_top - distanz + correct,
						left: $('.bounce_field').width() - block_width
					});
				}

				break;
			case (ausfallswinkel < 180):

				space_bottom = $('.bounce_field').height() - block_bottom;
				space_right = Math.abs(block_right - $('.bounce_field').width());

				//check unten
				ankathete_unten = space_bottom + block_height / 2;
				gegenkathete_unten = parseInt(Math.abs(Math.tan(((180 - ausfallswinkel) * Math.PI) / 180) * ankathete_unten));

				//checken rechts
				ankathete_rechts = space_right + block_width / 2;
				gegenkathete_rechts = parseInt(Math.abs(Math.tan(((ausfallswinkel - 90) * Math.PI) / 180) * ankathete_rechts));


				//Positionskorrektur
				correct = 0;

				// a^2 + b^2 = c^2 -> im ersten Schritt ist correct_x a oder b und im zweiten c

				correct_top_kathete = parseInt(Math.abs(Math.tan(((180 - ausfallswinkel) * Math.PI) / 180) * (block_height / 2)));
				correct_top = parseInt(Math.abs(Math.sqrt(Math.pow(correct_top_kathete, 2) + Math.pow(block_height / 2, 2))));

				correct_side_kathete = parseInt(Math.abs(Math.tan(((ausfallswinkel - 90) * Math.PI) / 180) * block_width / 2));
				correct_side = parseInt(Math.abs(Math.sqrt(Math.pow(correct_side_kathete, 2) + Math.pow(block_width / 2, 2))));

				hypotenuse_top = parseInt(Math.sqrt(Math.pow(ankathete_unten, 2) + Math.pow(gegenkathete_unten, 2)));
				hypotenuse_side = parseInt(Math.sqrt(Math.pow(ankathete_rechts, 2) + Math.pow(gegenkathete_rechts, 2)));

				//kürzere Rute

				corrected_top = Math.abs((hypotenuse_top - correct_top));
				corrected_side = Math.abs((hypotenuse_side - correct_side));

				if(corrected_top < corrected_side){
					distanz = gegenkathete_unten;
					framecollision = 'unten';
				}else {
					distanz = gegenkathete_rechts;
					framecollision = 'rechts';
				}

				if (framecollision == 'unten'){
					hypotenuse = hypotenuse_top - correct_top;
					correct = correct_top_kathete;
				}else {
					hypotenuse = hypotenuse_side - correct_side;
					correct = correct_side_kathete;
				}

				debug_direction = framecollision;
				if(debug_direction == 'unten') {
					debug_direction = 'quad_2_unten';
					debug_ankathete = ankathete_unten;
					debug_gegenkathete = gegenkathete_unten;
				}else{
					debug_direction = 'quad_2_rechts';
					debug_ankathete = ankathete_rechts;
					debug_gegenkathete = gegenkathete_rechts;
				}

				//geschw noch ausrechnen time_next_bounce

				time_next_bounce = Math.abs(hypotenuse) / block_speed;

				$(block).css({
					transition: "top linear " + time_next_bounce + "s, left linear " + time_next_bounce + "s"
				});

				rotate_value = 'rotate(' + ausfallswinkel + 'deg)';
				$('.angle').css({
					transform: rotate_value
				});

				if (framecollision == 'unten') {
					$(block).css({
						top: $('.bounce_field').height() - block_height,
						left: block_left + distanz - correct
					});
				}else{
					$(block).css({
						top: block_top + distanz - correct,
						left: $('.bounce_field').width() - block_width
					});
				}

				break;
			case (ausfallswinkel < 270):

				space_bottom = $('.bounce_field').height() - block_bottom;
				space_left = block_left;

				//check unten
				ankathete_unten = space_bottom + block_height / 2;
				gegenkathete_unten = parseInt(Math.abs(Math.tan(((ausfallswinkel - 180) * Math.PI) / 180) * ankathete_unten));

				//checken rechts
				ankathete_links = space_left + block_width / 2;
				gegenkathete_links = parseInt(Math.abs(Math.tan(((270 - ausfallswinkel) * Math.PI) / 180) * ankathete_links));

				//Positionskorrektur
				correct = 0;

				// a^2 + b^2 = c^2 -> im ersten Schritt ist correct_x a oder b und im zweiten c

				correct_top_kathete = parseInt(Math.abs(Math.tan(((ausfallswinkel - 180) * Math.PI) / 180) * (block_height / 2)));
				correct_top = parseInt(Math.abs(Math.sqrt(Math.pow(correct_top_kathete, 2) + Math.pow(block_height / 2, 2))));

				correct_side_kathete = parseInt(Math.abs(Math.tan(((270 - ausfallswinkel) * Math.PI) / 180) * block_width / 2));
				correct_side = parseInt(Math.abs(Math.sqrt(Math.pow(correct_side_kathete, 2) + Math.pow(block_width / 2, 2))));

				hypotenuse_top = parseInt(Math.sqrt(Math.pow(ankathete_unten, 2) + Math.pow(gegenkathete_unten, 2)));
				hypotenuse_side = parseInt(Math.sqrt(Math.pow(ankathete_links, 2) + Math.pow(gegenkathete_links, 2)));

				//kürzere Rute

				corrected_top = Math.abs((hypotenuse_top - correct_top));
				corrected_side = Math.abs((hypotenuse_side - correct_side));

				if(corrected_top < corrected_side){
					distanz = gegenkathete_unten;
					framecollision = 'unten';
				}else {
					distanz = gegenkathete_links;
					framecollision = 'links';
				}

				if (framecollision == 'unten'){
					hypotenuse = hypotenuse_top - correct_top;
					correct = correct_top_kathete;
				}else {
					hypotenuse = hypotenuse_side - correct_side;
					correct = correct_side_kathete;
				}

				debug_direction = framecollision;
				if(debug_direction == 'unten') {
					debug_direction = 'quad_3_unten';
					debug_ankathete = ankathete_unten;
					debug_gegenkathete = gegenkathete_unten;
				}else{
					debug_direction = 'quad_3_links';
					debug_ankathete = ankathete_links;
					debug_gegenkathete = gegenkathete_links;
				}

				//geschw noch ausrechnen
				time_next_bounce = hypotenuse / block_speed;
				$(block).css({
					transition: "top linear " + time_next_bounce + "s, left linear " + time_next_bounce + "s"
				});

				rotate_value = 'rotate(' + ausfallswinkel + 'deg)';
				$('.angle').css({
					transform: rotate_value
				});

				if (framecollision == 'unten') {
					$(block).css({
						top: $('.bounce_field').height() - block_height,
						left: block_left - distanz + correct
					});
				}else{
					$(block).css({
						top: block_top + distanz - correct,
						left: '0'
					});
				}

				break;
			case (ausfallswinkel < 360):

				space_top = block_top;
				space_left = block_left;

				//check oben
				ankathete_oben = space_top + block_height / 2;
				gegenkathete_oben = parseInt(Math.abs(Math.tan(((360 - ausfallswinkel) * Math.PI) / 180) * ankathete_oben));

				//checken links
				ankathete_links = space_left + block_width / 2;
				gegenkathete_links = parseInt(Math.abs(Math.tan(((ausfallswinkel - 270) * Math.PI) / 180) * ankathete_links));

				//Positionskorrektur
				correct = 0;

				// a^2 + b^2 = c^2 -> im ersten Schritt ist correct_x a oder b und im zweiten c

				correct_top_kathete = parseInt(Math.abs(Math.tan(((360 - ausfallswinkel) * Math.PI) / 180) * (block_height / 2)));
				correct_top = parseInt(Math.abs(Math.sqrt(Math.pow(correct_top_kathete, 2) + Math.pow(block_height / 2, 2))));

				correct_side_kathete = parseInt(Math.abs(Math.tan(((ausfallswinkel - 270) * Math.PI) / 180) * block_width / 2));
				correct_side = parseInt(Math.abs(Math.sqrt(Math.pow(correct_side_kathete, 2) + Math.pow(block_width / 2, 2))));

				hypotenuse_top = parseInt(Math.sqrt(Math.pow(ankathete_oben, 2) + Math.pow(gegenkathete_oben, 2)));
				hypotenuse_side = parseInt(Math.sqrt(Math.pow(ankathete_links, 2) + Math.pow(gegenkathete_links, 2)));

				//kürzere Rute

				corrected_top = Math.abs((hypotenuse_top - correct_top));
				corrected_side = Math.abs((hypotenuse_side - correct_side));

				if(corrected_top < corrected_side){
					distanz = gegenkathete_oben;
					framecollision = 'oben';
				}else {
					distanz = gegenkathete_links;
					framecollision = 'links';
				}

				if (framecollision == 'oben'){
					hypotenuse = hypotenuse_top - correct_top;
					correct = correct_top_kathete;
				}else {
					hypotenuse = hypotenuse_side - correct_side;
					correct = correct_side_kathete;
				}

				debug_direction = framecollision;
				if(debug_direction == 'oben') {
					debug_direction = 'quad_4_oben';
					debug_ankathete = ankathete_oben;
					debug_gegenkathete = gegenkathete_oben;
				}else{
					debug_direction = 'quad_4_links';
					debug_ankathete = ankathete_links;
					debug_gegenkathete = gegenkathete_links;
				}

				//geschw noch ausrechnen
				time_next_bounce = hypotenuse / block_speed;
				$(block).css({
					transition: "top linear " + time_next_bounce + "s, left linear " + time_next_bounce + "s"
				});

				rotate_value = 'rotate(' + ausfallswinkel + 'deg)';
				$('.angle').css({
					transform: rotate_value
				});

				if (framecollision == 'oben') {
					$(block).css({
						top:'0',
						left: block_left - distanz + correct
					});
				}else{
					$(block).css({
						top: block_top - distanz + correct,
						left: '0'
					});
				}

				break;
			default : break;
		}

		if (debug) {
			let debug_ankathete_element = document.createElement('DIV');
			$(debug_ankathete_element).addClass('debug_ankathete_element');
			$('.bounce_field').append(debug_ankathete_element);

			let debug_gegenkathete_element = document.createElement('DIV');
			$(debug_gegenkathete_element).addClass('debug_gegenkathete_element');
			$('.bounce_field').append(debug_gegenkathete_element);

			let new_pos_bottom = parseInt($(block).css('bottom')) + block_height / 2;
			let new_pos_left = parseInt($(block).css('left')) + block_width / 2;

			$('.angle').css('bottom', 'calc(' + new_pos_bottom + 'px - 2000px)');

			$('.angle').css('left', 'calc(' + new_pos_left + 'px - 1px)');


			$('.debug_ankathete_element').css({
				left: new_pos_left + 'px',
				bottom: 'calc(' + new_pos_bottom + 'px - ' + debug_ankathete + 'px)',
			});

			$('.debug_gegenkathete_element').css({
				left: new_pos_left + 'px',
				bottom: 'calc(' + new_pos_bottom + 'px - ' + debug_gegenkathete + 'px)',
			});

			if (debug_direction == 'quad_1_oben') {
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(0deg) translate(' + debug_gegenkathete + 'px)'
				});
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(90deg)'
				});
			}else if(debug_direction == 'quad_1_rechts'){
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(0deg)'
				});
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(90deg) translate(-' + debug_gegenkathete + 'px)'
				});
			} else if(debug_direction == 'quad_2_rechts'){
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(180deg)'
				});
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(90deg) translate(' + debug_gegenkathete + 'px)'
				});
			} else if(debug_direction == 'quad_2_unten'){
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(0deg) translate(' + debug_gegenkathete + 'px, ' + debug_ankathete + 'px)'
				});
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(90deg)'
				});
			} else if(debug_direction == 'quad_3_unten'){
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(0deg) translate(-' + debug_gegenkathete + 'px, ' + debug_ankathete + 'px)'
				});
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(270deg)'
				});
			} else if(debug_direction == 'quad_3_links'){
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(180deg)'
				});
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(90deg) translate(' + debug_gegenkathete + 'px, ' + debug_ankathete + 'px)'
				});
			} else if(debug_direction == 'quad_4_links'){
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(0deg)'
				});
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(90deg) translate(-' + debug_gegenkathete + 'px, ' + debug_ankathete + 'px)'
				});
			} else if(debug_direction == 'quad_4_oben'){
				$('.debug_ankathete_element').css({
					height: debug_ankathete + 'px',
					'border-bottom': 'white solid ' + debug_ankathete + 'px',
					transform: 'rotate(0deg) translate(-' + debug_gegenkathete + 'px)'
				});
				$('.debug_gegenkathete_element').css({
					height: debug_gegenkathete + 'px',
					'border-bottom': 'white solid ' + debug_gegenkathete + 'px',
					transform: 'rotate(270deg)'
				});
			}

		}

		setTimeout(function () {
			if (debug) {
				if (debug_bounce_counter < debug_bounce_limit) {
					debug_bounce_counter++;
					bounce(ausfallswinkel, block, framecollision);
				}
			}else {
				bounce(ausfallswinkel, block, framecollision);
			}
		}, time_next_bounce * 1000);

	}
</script>
</html>
